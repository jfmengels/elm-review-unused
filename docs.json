[{"name":"NoUnused.CustomTypeConstructorArgs","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Reports arguments of custom type constructors that are never used.\n\n    config =\n        [ NoUnused.CustomTypeConstructorArgs.rule\n        ]\n\nCustom type constructors can contain data that is never extracted out of the constructor.\nThis rule will warn arguments that are always pattern matched using a wildcard (`_`).\n\nFor package projects, custom types whose constructors are exposed as part of the package API are not reported.\n\nNote that this rule **may report false positives** if you compare custom types with the `==` or `/=` operators\n(and never destructure the custom type), like when you do `value == Just 0`, or store them in lists for instance with\n[`assoc-list`](https://package.elm-lang.org/packages/pzp1997/assoc-list/latest).\nThis rule attempts to detect when the custom type is used in comparisons, but it may still result in false positives.\n\n\n## Fail\n\n    type CustomType\n      = CustomType Used Unused\n\n    case customType of\n      CustomType value _ -> value\n\n\n## Success\n\n    type CustomType\n      = CustomType Used Unused\n\n    case customType of\n      CustomType value maybeUsed -> value\n\n\n## When not to enable this rule?\n\nIf you like giving names to all arguments when pattern matching, then this rule will not find many problems.\nThis rule will work well when enabled along with [`NoUnused.Patterns`](./NoUnused-Patterns).\n\nAlso, if you like comparing custom types in the way described above, you might pass on this rule, or want to be very careful when enabling it.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-unused/example --rules NoUnused.CustomTypeConstructorArgs\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"NoUnused.CustomTypeConstructors","comment":" Forbid having unused custom type constructors inside the project.\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Forbid having unused custom type constructors.\n\nðŸ”§ Running with `--fix` will automatically remove most of the reported errors.\n\n    config =\n        [ NoUnused.CustomTypeConstructors.rule []\n        ]\n\nNote that this rule reports any custom type constructor that isn't used\nanywhere _in the project_.\n\nIf the project is a package and the module that declared the type is exposed and\nthe type's constructors are exposed, then the constructors will not be reported.\n\nThis does not prevent you from using phantom types.\nI highly suggest chaning your phantom types to the following shape: `type TypeName = ConstructorName Never`.\nThis shape makes it obvious to tooling and readers that the type can't be created, so if it is used, it must be as a phantom type.\n\n**Deprecated configuration for phantom types**\n\n_I recommend changing your types like mentioned right above, and to configure the rule like `NoUnused.CustomTypeConstructors.rule []`.\nI'll keep this section and configuration option around until the next major version comes out._\n\n**Note**: At the time of writing, there may be cases where phantom types are not well detected.\nWhen an opaque type is defined in a dependency, we don't know whether a type variable should be considered as a phantom type.\n\nTherefore, sometimes this rule will need some help, by having you tell it what type variables of which type is a phantom type variable.\nThat's what the argument to the rule is for.\n\nTo explain that the `a` in `type Id a = Id String` from the `IdModule` module\ncorresponds to a phantom type variable, you would configure the rule like this:\n\n    config =\n        [ NoUnused.CustomTypeConstructors.rule\n            [ { moduleName = \"IdModule\"\n              , typeName = \"Id\"\n              , index = 0 -- Position of the phantom variable in the type's arguments\n              }\n            ]\n        ]\n\nThis rule could do a much better job than it currently does at figuring this out,\nby following the definitions of custom types and type aliases, until it finds out that the type\nvariable is not used, or that it hits the limit related to dependencies described above.\nIn the meantime, you can configure the rule with all the phantom type exceptions.\n\n**End of deprecated section**\n\n\n## Fail\n\n    module A exposing (a)\n\n    type MyType\n        = UsedType\n        | UnusedType -- Will get reported\n\n    a =\n        UsedType\n\n\n## Success\n\n    module A exposing (ExposedType(..))\n\n    type MyType\n        = UsedType\n\n    a =\n        UsedType\n\n    type ExposedType\n        = A\n        | B\n        | C\n\n    -----------------------\n    module A exposing (..)\n\n    type ExposedType\n        = A\n        | B\n        | C\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-unused/example --rules NoUnused.CustomTypeConstructors\n```\n\n","type":"List.List { moduleName : String.String, typeName : String.String, index : Basics.Int } -> Review.Rule.Rule"}],"binops":[]},{"name":"NoUnused.Dependencies","comment":" Forbid the use of dependencies that are never used in your project.\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Forbid the use of dependencies that are never used in your project.\n\nðŸ”§ Running with `--fix` will automatically remove all the reported errors.\n\nA dependency is considered unused if none of its modules are imported in the project.\n\n    config =\n        [ NoUnused.Dependencies.rule\n        ]\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-unused/example --rules NoUnused.Dependencies\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"NoUnused.Exports","comment":" Forbid the use of exposed elements that are never used in your project.\n\nðŸ”§ Running with `--fix` will automatically remove all the reported errors,\nexcept for the ones reported when using [`ignoreUsagesIn`](#ignoreUsagesIn).\nIt won't automatically remove unused modules though.\n\nIf the project is a package and the module that declared the element is exposed,\nthen nothing will be reported.\n\n@docs rule\n\n\n## Going one step further\n\nThis rule can be configured to report more unused elements than the default configuration.\n\n@docs Configuration, defaults, toRule\n\nBy default, this rule only reports exposed elements that are never imported in a different module.\nIt is however pretty common to have elements imported and used in non-production parts of the codebase,\nsuch as in tests or in a styleguide.\n\nFor instance, let's say there is a module `A` that exposes a function `someFunction`:\n\n    module A exposing (someFunction)\n\n    someFunction input =\n        doSomethingComplexWith input\n\nAnd there is this module to test `A.someFunction`:\n\n    module ATest exposing (tests)\n\n    import A\n    import Test exposing (Test, describe, test)\n\n    tests : Test\n    tests =\n        describe \"A.someFunction\"\n            [ test \"does something complex\" <|\n                \\() ->\n                    A.someFunction someInput\n                        |> Expect.equal someExpectedOutput\n            ]\n\nAnd let's say this is the only use of `A.someFunction` in the entire project.\nBecause `A.someFunction` is technically used in the project, this rule won't report it.\n\nBut since the function is not used in production code, it is a good practice to remove it, as that will remove the\namount of code that needs to be maintained unnecessarily. We can detect that using [`ignoreUsagesIn`](#ignoreUsagesIn).\n\n@docs ignoreUsagesIn\n\n@docs HelperPredicate, annotatedBy, suffixedBy, prefixedBy\n\n\n## Try it out\n\nYou can try this rule out by running the following commands:\n\nUsing the default configuration:\n\n```bash\nelm-review --template jfmengels/elm-review-unused/example --rules NoUnused.Exports\n```\n\nUsing `ignoreUsagesIn` with the following configuration:\n\n    NoUnused.Exports.defaults\n        |> NoUnused.Exports.ignoreUsagesIn\n            { filePredicate = \\{ moduleName, filePath, isInSourceDirectories } -> not isInSourceDirectories\n            , helpersAre = [ annotatedBy \"@helper\", suffixedBy \"_FOR_TESTS\" ]\n            }\n        |> NoUnused.Exports.toRule\n\n```bash\nelm-review --template jfmengels/elm-review-unused/example-ignore-tests --rules NoUnused.Exports\n```\n\n","unions":[{"name":"Configuration","comment":" Configuration for the rule. Use [`defaults`](#defaults) to get a default configuration and use [`toRule`](#toRule) to turn it into a rule.\nYou can change the configuration using [`ignoreUsagesIn`](#ignoreUsagesIn).\n","args":[],"cases":[]},{"name":"HelperPredicate","comment":" Identifies a helper predicate. See [`ignoreUsagesIn`](#ignoreUsagesIn) for how to use and create these.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"annotatedBy","comment":" Prevents reporting usages of elements that contain a specific tag in their documentation.\n\nGiven the following configuration\n\n    NoUnused.Exports.defaults\n        |> NoUnused.Exports.ignoreUsagesIn\n            { filePredicate = filePredicate\n            , helpersAre = [ annotatedBy \"@test-helper\" ]\n            }\n        |> NoUnused.Exports.toRule\n\nany element that has `@test-helper` in its documentation will not be reported as unused (as long as its used at least once in the project):\n\n    {-| @test-helper\n    -}\n    someFunction input =\n        doSomethingComplexWith input\n\nA recommended practice is to have annotations start with `@`.\n\nYou can use this function several times to define multiple annotations.\n\n","type":"String.String -> NoUnused.Exports.HelperPredicate"},{"name":"defaults","comment":" Default configuration.\n","type":"NoUnused.Exports.Configuration"},{"name":"ignoreUsagesIn","comment":" Configures the rule to report elements that are used only in specific locations.\n\n    import NoUnused.Exports exposing (annotatedBy, prefixedBy, suffixedBy)\n\n    config =\n        [ NoUnused.Exports.defaults\n            |> NoUnused.Exports.ignoreUsagesIn\n                { filePredicate =\n                    \\{ moduleName, filePath, isInSourceDirectories } ->\n                        not isInSourceDirectories\n                            || String.endsWith \"/Example.elm\" filePath\n                , helpersAre = [ annotatedBy \"TEST\" ]\n                }\n            |> NoUnused.Exports.toRule\n        ]\n\nElements reported using this configuration won't be automatically fixed as they require removing the code\nthat uses the element.\n\nThis function needs to know two things:\n\n1.  Which files should be ignored. This is done by providing a function that returns\n    `True` for files that should be ignored, and `False` otherwise.\n    A common use-case is to ignore files that are not in the `\"source-directories\"` such as tests, which is indicated by\n    `isInSourceDirectories` that is given as an argument to the function. If you need something more custom, you can use either\n    the `filePath` or `moduleName` of the Elm module.\n\n2.  How to mark allowed usages. A problem with this approach is it will also report elements that are legitimately\n    exposed to enable non-production use-cases, for instance enabling tests that make assertions on API internals or on\n    functions that use opaque types that can't be easily constructed. This rule needs help identifying them to avoid\n    reporting these use-cases. This is done by providing a list of [`HelperPredicate`](#HelperPredicate).\n\n","type":"{ filePredicate : { moduleName : Elm.Syntax.ModuleName.ModuleName, filePath : String.String, isInSourceDirectories : Basics.Bool } -> Basics.Bool, helpersAre : List.List NoUnused.Exports.HelperPredicate } -> NoUnused.Exports.Configuration -> NoUnused.Exports.Configuration"},{"name":"prefixedBy","comment":" Prevents reporting usages of elements whose name start with a specific string.\n\nGiven the following configuration\n\n    NoUnused.Exports.defaults\n        |> NoUnused.Exports.ignoreUsagesIn\n            { filePredicate = filePredicate\n            , helpersAre = [ prefixedBy \"test_\" ]\n            }\n        |> NoUnused.Exports.toRule\n\nany element that starts with `\"test_\"` will not be reported as unused (as long as its used at least once in the project):\n\n    test_someFunction input =\n        doSomethingComplexWith input\n\nYou can use this function several times to define multiple prefixes.\n\n","type":"String.String -> NoUnused.Exports.HelperPredicate"},{"name":"rule","comment":" Report functions and types that are exposed from a module but that are never\nused in other modules. Also reports when a module is entirely unused.\n\n    config =\n        [ NoUnused.Exports.rule\n        ]\n\nThis is equivalent to `NoUnused.Exports.toRule NoUnused.Exports.defaults`.\n\n","type":"Review.Rule.Rule"},{"name":"suffixedBy","comment":" Prevents reporting usages of elements whose name end with a specific string.\n\nGiven the following configuration\n\n    NoUnused.Exports.defaults\n        |> NoUnused.Exports.ignoreUsagesIn\n            { filePredicate = filePredicate\n            , helpersAre = [ suffixedBy \"_FOR_TESTS\" ]\n            }\n        |> NoUnused.Exports.toRule\n\nany element that ends with `\"_FOR_TESTS\"` will not be reported as unused (as long as its used at least once in the project):\n\n    someFunction_FOR_TESTS input =\n        doSomethingComplexWith input\n\nYou can use this function several times to define multiple suffixes.\n\n","type":"String.String -> NoUnused.Exports.HelperPredicate"},{"name":"toRule","comment":" Creates a rule that reports unused exports using a [`Configuration`](#Configuration).\n","type":"NoUnused.Exports.Configuration -> Review.Rule.Rule"}],"binops":[]},{"name":"NoUnused.Modules","comment":" Forbid the use of modules that are never used in your project.\n\n**@deprecated** This rule has been deprecated, as it has now been integrated into [`NoUnused.Exports`](NoUnused-Exports).\nYou should use that rule instead.\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Forbid the use of modules that are never used in your project.\n\nA module is considered used if\n\n  - it contains a `main` function (be it exposed or not)\n  - it imports the `Test` module\n  - it is imported in any other modules, even if it is not used.\n  - the project is a package and the module is part of the `elm.json`'s `exposed-modules`\n  - it is named `ReviewConfig`\n\n```elm\nconfig =\n    [ NoUnused.Modules.rule\n    ]\n```\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-unused/example --rules NoUnused.Modules\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"NoUnused.Parameters","comment":" Report parameters that are not used.\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Report parameters that are not used.\n\nðŸ”§ Running with `--fix` will automatically remove some of the reported errors.\n\n    config =\n        [ NoUnused.Parameters.rule\n        ]\n\nThis rule looks within function arguments, let functions and lambdas to find any values that are unused. It will report any parameters that are not used.\n\n\n## Fixes for lambdas\n\nWe're only offering fixes for lambdas here because we believe unused parameters in functions are a code smell that should be refactored.\n\n\n## Fail\n\nValue `number` is not used:\n\n    add1 number =\n        1\n\nThe rule will also report parameters that are only used to be passed again to the containing recursive function:\n\n    last list unused =\n        case list of\n            [] ->\n                Nothing\n\n            [ a ] ->\n                Just a\n\n            _ :: rest ->\n                last rest unused\n\n\n## Success\n\n    add1 number =\n        number + 1\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-unused/example --rules NoUnused.Parameters\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"NoUnused.Patterns","comment":" Report useless patterns and pattern values that are not used.\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Report useless patterns and pattern values that are not used.\n\nðŸ”§ Running with `--fix` will automatically remove all the reported errors.\n\n    config =\n        [ NoUnused.Patterns.rule\n        ]\n\nThis rule looks within let..in blocks and case branches to find any patterns that are unused. It will report any useless patterns as well as any pattern values that are not used.\n\n\n## Fail\n\nValue `something` is not used:\n\n    case maybe of\n        Just something ->\n            True\n\n        Nothing ->\n            False\n\n\n## Success\n\n    case maybe of\n        Just _ ->\n            True\n\n        Nothing ->\n            False\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-unused/example --rules NoUnused.Patterns\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"NoUnused.Variables","comment":" Report variables or types that are declared or imported but never used inside of a module.\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Report variables or types that are declared or imported but never used.\n\nðŸ”§ Running with `--fix` will automatically remove all the reported errors.\n\n    config =\n        [ NoUnused.Variables.rule\n        ]\n\n\n## Fail\n\n    module A exposing (a, b)\n\n    import UnusedImport\n\n    a n =\n        n + 1\n\n    b =\n        let\n            unused =\n                some thing\n\n            _ =\n                someOther thing\n        in\n        2\n\n    c =\n        a 2\n\n\n## Success\n\n    module A exposing (a, b)\n\n    a n =\n        n + 1\n\n    b =\n        2\n\n\n## Exception\n\nTo avoid resorting to weird workarounds that are sometimes used in internal interactive examples, the rule won't report\nvalues assigned to `_` if a direct call to `Debug.log` is assigned to it.\n\n    a value =\n        let\n            _ =\n                Debug.log \"value\" value\n        in\n        value + 1\n\nIf you enable the [`NoDebug.Log`](https://package.elm-lang.org/packages/jfmengels/elm-review-debug/latest/NoDebug-Log) rule\nfrom the [`jfmengels/elm-review-debug`](https://package.elm-lang.org/packages/jfmengels/elm-review-debug/latest/) package,\nand configure it to ignore the locations where it's acceptable, then the combination of both rules will make sure to\nclean up code like the above in all the other locations.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-unused/example --rules NoUnused.Variables\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]}]